一、创建版本库
	初始化一个Git仓库， 使用 git init 命令。
	添加文件到Git仓库， 分两步：
	第一步， 使用命令 git add <file> ， 注意， 可反复多次使用， 添加
	多个文件；
	第二步， 使用命令 git commit ， 完成。 
	
二、时光机穿梭
	要随时掌握工作区的状态， 使用 git status 命令。
	如果 git status 告诉你有文件被修改过， 用 git diff 可以查看修改内
	容。 
	备注：Git也是一样， 每当你觉得文件修改到一定程度的时候， 就可以“保存一个快照”， 这个快照在Git中被称为 commit 。Git中Commit id 被称为版本号。
	
	a、版本回退
		HEAD 指向的版本就是当前版本， 因此， Git允许我们在版本的历史之间穿梭， 使用命令 git reset --hard commit_id 。穿梭前， 用 git log 可以查看提交历史， 以便确定要回退到哪个版本。要重返未来， 用 git reflog 查看命令历史， 以便确定要回到未来的哪个版本。 
	 
	b、工作区和暂存区
		工作区（Working Directory）：就是你在电脑里能看到的目录 。
		版本库（Repository）：工作区有一个隐藏目录 .git ， 这个不算工作区， 而是Git的版本库。 Git的版本库里存了很多东西， 其中最重要的就是称为stage（或者叫index） 的暂存区， 还有Git为我们自动创建的第一个分支 master ， 以及指向 master 的一个指针叫 HEAD 。 
		
		前面讲了我们把文件往Git版本库里添加的时候， 是分两步执行的：
		第一步是用 git add 把文件添加进去， 实际上就是把文件修改添加到暂存区；
		第二步是用 git commit 提交更改， 实际上就是把暂存区的所有内容提交到当前分支。
		因为我们创建Git版本库时， Git自动为我们创建了唯一一个 master 分支， 所以，现在， git commit 就是往 master 分支上提交更改。你可以简单理解为， 需要提交的文件修改通通放到暂存区， 然后， 一次性提交暂存区的所有修改 。
		
		暂存区是Git非常重要的概念， 弄明白了暂存区， 就弄明白了Git的很多操作到底干了什么。
	c、管理修改
		 
		回顾一下操作过程：第一次修改 -> git add -> 第二次修改 -> git commit你看， 我们前面讲了， Git管理的是修改， 当你用 git add 命令后， 在工作区的第一次修改被放入暂存区， 准备提交， 但是， 在工作区的第二次修改并没有放入暂存区， 所以， git commit 只负责把暂存区的修改提交了， 也就是第一次的修改被提交了， 第二次的修改不会被提交。提交后， 用 git diff HEAD -- readme.txt 命令可以查看工作区和版本库里面最新版本的区别： 
		理解了Git是如何跟踪修改的， 每次修改， 如果不 add 到暂存区， 那就
		不会加入到 commit 中。 
		
	d、撤销修改
		命令 git checkout -- readme.txt 意思就是， 把 readme.txt 文件在工作区的修改全部撤销， 这里有两种情况：一种是 readme.txt 自修改后还没有被放到暂存区， 现在， 撤销修改就回到和版本库一模一样的状态；一种是 readme.txt 已经添加到暂存区后， 又作了修改， 现在， 撤销修改就回到添加到暂存区后的状态。总之， 就是让这个文件回到最近一次 git commit 或 git add 时的状态。 
		git checkout -- file 命令中的 -- 很重要， 没有 -- ， 就变成了“切换到另一个分支”的命令， 我们在后面的分支管理中会再次遇到 git checkout 命令。 
		git reset 命令既可以回退版本， 也可以把暂存区的修改回退到工作区。 当我们用 HEAD 时， 表示最新的版本。 
		
		又到了小结时间。
		场景1：当你改乱了工作区某个文件的内容， 想直接丢弃工作区的修改时， 用命令 git checkout -- file 。
		场景2：当你不但改乱了工作区某个文件的内容， 还添加到了暂存区时， 想丢弃修改， 分两步， 第一步用命令 git reset HEAD file ， 就回到了场景1， 第二步按场景1操作。
		场景3：已经提交了不合适的修改到版本库时， 想要撤销本次提交， 参考版本回退
		一节， 不过前提是没有推送到远程库。 
	e、删除文件
		git checkout 其实是用版本库里的版本替换工作区的版本， 无论工作区是修改还是删除， 都可以“一键还原” 。
		命令 git rm 用于删除一个文件。 如果一个文件已经被提交到版本库， 那么你永远不用担心误删， 但是要小心， 你只能恢复文件到最新版本， 你会丢失最近一次提交后你修改的内容。 
		
三、远程仓库
	1、添加远程仓库
		要关联一个远程库， 使用命令 git remote add origin git@servername:path/repo-name.git ；关联后， 使用命令 git push -u origin master 第一次推送master分支的所有内容；此后， 每次本地提交后， 只要有必要， 就可以使用命令 git push originmaster 推送最新修改；分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在， 也就是有没有联网都可以正常工作， 而SVN在没有联网的时候是拒绝干活的！当有网络
		的时候， 再把本地提交推送一下就完成了同步， 真是太方便了！
	2、从远程仓库克隆
		要克隆一个仓库， 首先必须知道仓库的地址， 然后使用 git clone 命令克隆。
		Git支持多种协议， 包括 https ， 但通过 ssh 支持的原生 git 协议速度最快。 
四、分支管理
	1、创建与合并分支
		Git鼓励大量使用分支：
		查看分支： git branch
		创建分支： git branch <name>
		切换分支： git checkout <name>
		创建+切换分支： git checkout -b <name>
		合并某分支到当前分支： git merge <name>
		删除分支： git branch -d <name> 
	2、解决冲突
		当Git无法自动合并分支时， 就必须首先解决冲突。 解决冲突后， 再提交， 合并完成。
		用 git log --graph 命令可以看到分支合并图。 
	3、分支管理策略
		在实际开发中， 我们应该按照几个基本原则进行分支管理：
		首先， master 分支应该是非常稳定的， 也就是仅用来发布新版本， 平时不能在上面干活；那在哪干活呢？干活都在 dev 分支上， 也就是说， dev 分支是不稳定的， 到某个时候， 比如1.0版本发布时， 再把 dev 分支合并到 master 上， 在 master 分支发布1.0版本； 
		
		Git分支十分强大， 在团队开发中应该充分应用。
		合并分支时， 加上 --no-ff 参数就可以用普通模式合并， 合并后的历史有分支，
		能看出来曾经做过合并， 而 fast forward 合并就看不出来曾经做过合并。 
	4、bug分支
		修复bug时， 我们会通过创建新的bug分支进行修复， 然后合并， 最后删除；当手头工作没有完成时， 先把工作现场 git stash 一下， 然后去修复bug， 修复后， 再 git stash pop ， 回到工作现场。 
	5、feature分支
		开发一个新feature， 最好新建一个分支；
		如果要丢弃一个没有被合并过的分支， 可以通过 git branch -D<name> 强行删除。 
	6、多人协作、推送分支
		master 分支是主分支， 因此要时刻与远程
		dev 分支是开发分支， 团队所有成员都需要在上面工作， 所以也需要与远程同步；
		bug分支只用于在本地修复bug， 就没必要推到远程了， 除非老板要看看你每周到底修复了几个bug；
		feature分支是否推到远程， 取决于你是否和你的小伙伴合作在上面开发。
		总之， 就是在Git中， 分支完全可以在本地自己藏着玩， 是否推送， 视你的心情而
		定！ 
		因此， 多人协作的工作模式通常是这样：
		1. 首先， 可以试图用 git push origin branch-name 推送自己的修改；
		2. 如果推送失败， 则因为远程分支比你的本地更新， 需要先用 git pull 试图合并；
		3. 如果合并有冲突， 则解决冲突， 并在本地提交；
		4. 没有冲突或者解决掉冲突后， 再用 git push origin branch-name 推送就能成功！如果 git pull 提示“no tracking information”， 则说明本地分支和远程分支的链接关系没有创建， 用命令 git branch --set-upstream branch-nameorigin/branch-name 。这就是多人协作的工作模式， 一旦熟悉了， 就非常简单。 
		
		小结
		查看远程库信息， 使用 git remote -v ；
		本地新建的分支如果不推送到远程， 对其他人就是不可见的；
		从本地推送分支， 使用 git push origin branch-name ， 如果推送失败，先用 git pull 抓取远程的新提交； 
		在本地创建和远程分支对应的分支， 使用 git checkout -b branch-name  origin/branch-name ， 本地和远程分支的名称最好一致；
		建立本地分支和远程分支的关联， 使用 git branch --set-upstreambranch-name origin/branch-name ；
		从远程抓取分支， 使用 git pull ， 如果有冲突， 要先处理冲突。 
		
		
		
		
		
		
		
		
		
		
		
		
	
